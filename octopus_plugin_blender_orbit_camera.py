# -*- coding: utf-8 -*-
"""SDXL10_octopusAPI_orbit_camera_linux.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P6fWDskpJfEc7hNM9IgUPz8dL_wVB44V
"""

import os

### BEGIN USER EDITABLE SECTION ###
dependencies = [
    "pip install -q flask pyngrok",
    "pip install -q joblib",
    "pip install uuid",
    "pip install gdown",
    "apt install libgl1-mesa-glx",
    "wget https://download.blender.org/release/Blender3.5/blender-3.5.1-linux-x64.tar.xz -O BlenderDownload.tar.xz",
    "tar xf BlenderDownload.tar.xz"
]

for command in dependencies:
    os.system(command)

config_str = '''
{
    "device_map": {
     "cuda:0": "10GiB",
     "cpu": "30GiB"
     },
     "models": [
         {
             "key": "10133_integration.blend",
             "name": "blender_model",
             "access_token": "https://drive.google.com/uc?id=1UAycFFA3UvSCVBwyTMZ12oD9sDiRancO&export=download"
         },
         {
             "key": "orbit.py",
             "name": "script_model",
             "access_token": "https://drive.google.com/uc?id=123-L8cZ9vqMMIPrFvMP78lhPdmGrre_7&export=download"
         }
     ],
     "functions": [
         {
             "name": "orbit-camera",
             "description": "Renders an image showing the machine from given angle with aditional control of the zoom and tilt",


             "parameters": {
                 "type": "object",
                 "properties": {
                     "position":{
                         "type": "int",
                         "description": "the value from 1-100 representing 360 degree rotation arround the machine, it start on the right center of the machine"
                     },
                     "tilt":{
                         "type": "string",
                         "enum": ["up", "center", "down"],
                         "description": "value that controls the camera rotation in x axis, when the camera is tilted down machine is shown from top"
                     },
                     "zoom":{
                         "type": "string",
                         "enum": ["far", "middle", "close"],
                         "description": "value that controls the camera zoom, it can be used to look at the machine closer or to see more of it on the same render"
                     },
                     "resolution":{
                         "type": "string",
                         "enum": ["full-hd", "4k"],
                         "description": "allows to select resolution desired by user, 4k resolution helps to see finer detail on the rendered image"
                     }
                 },
                 "required": ["position"]
             },
             "input_type": "json",
             "return_type": "image/png"
         }

     ]
 }
'''

import gdown

class BlenderModelManager:
    def __init__(self, key, name, token):
        extension = key.split(".")[-1]
        self.file = f"{name}.{extension}"
        gdown.download(token, output=self.file, quiet=False)

def find(name, path):
    for root, dirs, files in os.walk(path):
        if name in files:
            return os.path.join(os.path.relpath(root,start = os.curdir), name)

try:
    import google.colab
    # Change to /content directory
    os.chdir('/content')
    print("Changed directory to /content")
except ImportError:
    print("Not running in Colab")

### END USER EDITABLE SECTION ###

import json
import base64
from io import BytesIO
from flask import Flask, request, jsonify
import uuid
import time

config = json.loads(config_str)
app = Flask(__name__)

class ModelManager:
    def __init__(self, config):
        self.config = config
        self.models = {}
        self.device = self.select_device()

    def select_device(self):
        device_map = self.config.get('device_map', {})
        available_devices = list(device_map.keys())
        return available_devices[0] if available_devices else "cpu"

    def setup(self):
        self.models.clear()

        # Loading models from configuration
        for model_info in self.config["models"]:
            model_key = model_info["key"]
            model_name = model_info["name"]
            model_access_token = model_info["access_token"]
            try:
                ### BEGIN USER EDITABLE SECTION ###
                model = BlenderModelManager(model_key,model_name, model_access_token)
                self.models[model_name] = model
                ### END USER EDITABLE SECTION ###
            except Exception as e:
                print(f"Error loading model {model_name}: {e}")

    def infer(self, parameters):
        try:
            ### BEGIN USER EDITABLE SECTION ###
            output_filename = str(uuid.uuid4())
            blender_path = find('blender', 'blender-3.5.1-linux-x64')
            blender_model = self.models["blender_model"]
            script_model = self.models["script_model"]
            main_command = f"{blender_path} -b {blender_model.file} -noaudio --python {script_model.file} -- --position {parameters['position']} --output_filename {output_filename}"
            if 'tilt' in parameters:
                tilt_command = f" --tilt {parameters['tilt']}"
            else:
                tilt_command = ""
            if 'zoom' in parameters:
                zoom_command = f" --zoom {parameters['zoom']}"
            else:
                zoom_command = ""
            if 'resolution' in parameters:
                resolution_command = f" --resolution {parameters['resolution']}"
            else:
                resolution_command = ""

            command = main_command+tilt_command+zoom_command+resolution_command
            print(command)
            os.system(command)

            while os.path.exists(output_filename+".png") == False:
                time.sleep(5)

            return output_filename+".png"

            ### END USER EDITABLE SECTION ###
        except Exception as e:
            print(f"Error during inference: {e}")
            return None


model_manager = ModelManager(config)

@app.route('/setup', methods=['POST'])
def setup():
    model_manager.setup()
    return jsonify({"comment": "models loaded successfully", "status": "Ok"}), 201

@app.route('/<function_name>', methods=['POST'])
def generic_route(function_name):
    function_config = next((f for f in config["functions"] if f["name"] == function_name), None)

    if not function_config:
        return jsonify({"error": "Invalid endpoint"}), 404

    if function_config["input_type"] != "json":
        return jsonify({"error": f"Unsupported input type {function_config['input_type']}"}), 400

    data = request.json
    parameters = {k: data[k] for k in function_config["parameters"]["properties"].keys() if k in data}

    result = model_manager.infer(parameters)
    if result:
        return app.response_class(result, content_type=function_config["return_type"]), 201
    else:
        return jsonify({"error": "Error during inference"}), 500

@app.errorhandler(Exception)
def handle_exception(e):
    # Generic exception handler
    return jsonify(error=str(e)), 500

import threading
from pyngrok import ngrok
import time

# Start the Flask server in a new thread
threading.Thread(target=app.run, kwargs={"use_reloader": False}).start()

# Set up Ngrok to create a tunnel to the Flask server
public_url = ngrok.connect(5000).public_url

function_names = [func['name'] for func in config["functions"]]

print(f" * ngrok tunnel \"{public_url}\" -> \"http://127.0.0.1:{5000}/\"")

# Loop over function_names and print them
for function_name in function_names:
    time.sleep(5)
    print(f'Endpoint here: {public_url}/{function_name}')

import requests

BASE_URL = f"{public_url}"

### BEGIN USER EDITABLE SECTION ###
def setup_test():
    response = requests.post(f"{BASE_URL}/setup")

    # Check if the request was successful
    if response.status_code == 201:
        return (True, response.json())  # True indicates success
    else:
        return (False, response.json())  # False indicates an error

def infer_test(position=60, zoom="far", resolution="full-hd", tilt="down"):
    headers = {
        "Content-Type": "application/json"
    }
    data = {
        "position": position,
        "zoom": zoom,
        "resolution": resolution,
        "tilt":tilt
    }
    response = requests.post(f"{BASE_URL}/orbit-camera", headers=headers, json=data)

    if response.status_code == 201:
        # Save the image to a file
        os.replace(response.content, "output_image.png")
        print("Image saved as output_image.jpeg!")
        return (True, "Image saved successfully!")  # True indicates success
    else:
        return (False, response.json())  # False indicates an error

### END USER EDITABLE SECTION ###

# Testing
result_setup = setup_test()
print(result_setup)

import time

start = time.time()

result_infer = infer_test()
print(result_infer)

end = time.time()
print(end - start)